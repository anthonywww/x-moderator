#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import platform
import re
import json
import random
import argparse
import mariadb
import logging
from typing import List, Dict, Any
from datetime import datetime, timezone
from operator import itemgetter
from contextlib import contextmanager
from names import ADJECTIVES, LAST_NAMES

# Constants
NAME = "migrator"
VERSION = "1.0.1"
SCHEMA_PATH = "migrations"
DB_TABLE = "metadata"

# Environment variables for database connection
DB_HOST = os.environ.get("MIGRATOR_DB_HOSTNAME", "x-moderator-mariadb")
DB_PORT = int(os.environ.get("MIGRATOR_DB_PORT", 3306))
DB_NAME = os.environ.get("MIGRATOR_DB_NAME", "x_moderator")
DB_USERNAME = os.environ.get("MIGRATOR_DB_USERNAME", "username")
DB_PASSWORD = os.environ.get("MIGRATOR_DB_PASSWORD", "password")

class Migrator:

    def __init__(self, logger):
        self.logger = logger
        self.conn = None

    def _init_db(self):
        if self.conn is None or self.conn.closed:
            self.conn = self.db_connection()
        return self.conn

    def db_connection(self):
        try:
            conn = mariadb.connect(
                host=DB_HOST,
                user=DB_USERNAME,
                password=DB_PASSWORD,
                database=DB_NAME,
            )
            self.logger.info("Database connection established.")
            return conn
        except mariadb.Error as e:
            self.logger.error(f"Failed to connect to database: {e}")
            raise

    def create_schema(self) -> dict:
        latest_version = max(version['version'] for version in self.get_available_versions()) if self.get_available_versions() else 0
        new_version = latest_version + 1

        adjective = random.choice(names.ADJECTIVES)
        last_name = random.choice(names.LAST_NAMES)
        schema_name = f"{adjective}-{last_name}"

        new_schema_path = os.path.join(SCHEMA_PATH, str(new_version))
        os.makedirs(new_schema_path, exist_ok=True)

        for sql_type in ["up", "down"]:
            file_content = f"""-- Schema Overlay: {schema_name} ({new_version})
-- Created On: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
--
-- DO NOT EDIT THIS FILE AFTER IT HAS BEEN COMMITTED
-- CREATE A NEW SCHEMA OVERLAY `migrator.py create` INSTEAD
--
"""

            with open(os.path.join(new_schema_path, f"{sql_type}.sql"), "w") as f:
                f.write(file_content)

        # Update Manifest (assuming manifest.json exists)
        if os.path.exists(f"{SCHEMA_PATH}/manifest.json"):
            with open(f"{SCHEMA_PATH}/manifest.json", "r+") as file:
                data = json.load(file)
                data.append({"version": new_version, "name": schema_name, "date": datetime.now().isoformat()})
                file.seek(0)
                json.dump(data, file, indent='\t')
                file.truncate()

        self.logger.info(f"Created new schema version at: {new_schema_path}")
        return {"version": new_version, "name": schema_name}

    def _update_metadata(self, cursor, version: int):
        try:
            self.logger.info("Attempting to update metadata...")

            cursor.execute("UPDATE metadata SET `value` = %s, `date_updated` = UNIX_TIMESTAMP() WHERE `key` = 'migration_data'", (json.dumps({"version": version}),),)

            if cursor.rowcount == 0:
                cursor.execute("INSERT INTO metadata (`key`, `value`, `date_updated`) VALUES (%s, %s, UNIX_TIMESTAMP())", ("migration_data", json.dumps({"version": version})),)

            self.logger.info(f"Metadata updated to version {version}")

            cursor.connection.commit()
            self.logger.info("Transaction committed for metadata update.")
            cursor.execute("SELECT `value` FROM metadata WHERE `key` = 'migration_data' ORDER BY `date_updated` DESC LIMIT 1")
            result = cursor.fetchone()
            if result:
                current_version = json.loads(result[0])["version"]
                self.logger.info(f"Current version after metadata update: {current_version}")
                if current_version != version:
                    self.logger.error(f"Version mismatch after update attempt. Set to {version}, but got {current_version}")
            else:
                self.logger.error("Failed to find the updated version in metadata or no rows exist after operation.")
        except mariadb.Error as e:
            self.logger.error(f"Error updating or inserting metadata: {e}")
            cursor.connection.rollback()
            raise

    def get_available_versions(self):
        try:
            # Assuming SCHEMA_PATH is where your migration files are stored
            versions = []
            for entry in os.listdir(SCHEMA_PATH):
                full_path = os.path.join(SCHEMA_PATH, entry)
                if os.path.isdir(full_path):
                    try:
                        int_version = int(entry)
                        versions.append({"version": int_version, "name": f"{entry}"})  # You might want to read the name from a file or config
                    except ValueError:
                        continue  # Skip entries that aren't integer directories
            return sorted(versions, key=lambda x: x['version'])
        except Exception as e:
            self.logger.error(f"Failed to get available versions: {e}")
            return []

    def get_current_version(self, cursor):
        try:
            cursor.execute("SELECT value FROM metadata WHERE `key` = 'migration_data'")
            result = cursor.fetchone()
            if not result:
                self.logger.warn("No migration metadata found. Assuming version 0.")
                return 0
            data = json.loads(result[0])
            return int(data.get("version", 0))
        except Exception as e:
            self.logger.error(f"Error fetching current version: {e}")
            return 0  # or raise, depending on how you want to handle this

    def exec_sql_file(self, cursor, sql_file: str):
        self.logger.info(f"Starting execution of SQL file: {sql_file}")
        with open(sql_file, "r") as file:
            statements = []
            current_statement = ""

            for line in file:
                line = line.strip()
                if line.startswith("--") or not line:
                    continue
                current_statement += line + " "
                if line.endswith(";"):
                    statements.append(current_statement.strip())
                    current_statement = ""

            if current_statement:  # In case the file doesn't end with a semicolon
                statements.append(current_statement.strip())

            for statement in statements:
                if statement:
                    try:
                        cursor.execute(statement)
                        self.logger.info(
                            f"Executed SQL: {statement[:100]}..."
                        )  # Log first 100 chars for brevity
                    except mariadb.Error as e:
                        self.logger.error(
                            f"SQL Execution Error in {sql_file}: {
                                e} for statement: {statement}"
                        )
                        raise
        self.logger.info(f"Completed SQL file execution for {sql_file}")

    def migrate(self, target_version: int) -> None:
        with self._init_db() as conn:
            with conn.cursor() as cursor:
                
                current_version = self.get_current_version(cursor)

                if current_version == target_version:
                    self.logger.warn(f"Already at version {target_version}. No migration needed.")
                    return

                self.logger.debug(f"Starting migration from version: {current_version} to target version: {target_version}")
                
                conn.autocommit = False
                self.logger.debug("Autocommit is set to false for this migration session.")

                versions = self.get_available_versions()

                # If target_version is 0, set it to the oldest version available
                if target_version == 0:
                    target_version = min(version['version'] for version in versions)

                for version in versions:
                    if current_version < version['version'] <= target_version or \
                    current_version > version['version'] >= target_version:
                        action = "up" if version['version'] > current_version else "down"
                        
                        self.logger.info(f"Migrating {action} to version: {version['version']}")
                        
                        try:
                            cursor.execute("START TRANSACTION")
                            self.exec_sql_file(cursor, f"{SCHEMA_PATH}/{version['version']}/{action}.sql")
                            new_version = version['version'] if action == 'up' else max((v['version'] for v in versions if v['version'] < version['version']), default=target_version)
                            self._update_metadata(cursor, new_version)
                            conn.commit()
                            self.logger.info(f"Committed changes for version {version['version']}")
                            current_version = new_version
                        except Exception as e:
                            conn.rollback()
                            self.logger.error(f"Rolling back migration due to error: {e}")
                            raise

                if current_version != target_version:
                    raise ValueError(f"Migration ended at version {current_version}, expected {target_version}")
                else:
                    self.logger.info(f"Migration completed to version {current_version}")


class Logger:
    def __init__(self, quiet=False):
        self.logger = logging.getLogger('migrator_logger')
        if not self.logger.handlers:  # Check if handlers are already added
            self.logger.setLevel(logging.DEBUG if not quiet else logging.WARNING)
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(
                fmt="%(asctime)s [%(levelname)s] %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S"
            ))
            self.logger.addHandler(handler)

        if quiet:
            self.info = lambda msg: None # NOP
        else:
            self.info = self.logger.info

    def warn(self, msg):
        self.logger.warning(msg)

    def error(self, msg):
        self.logger.error(msg)

    def debug(self, msg):
        self.logger.debug(msg)

    # Redefine to hide implementation details
    def info(self, msg):
        self.logger.info(msg)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog=NAME, description=f"{NAME} v{VERSION}")
    parser.add_argument("-q", "--quiet", action="store_true", help="Do not print informational messages")
    subparsers = parser.add_subparsers(dest="command")

    # Add subparsers for different commands
    subparsers.add_parser("list", help="Lists all available overlay schema versions")
    subparsers.add_parser("status", help="Show the current status")
    create_parser = subparsers.add_parser("create", help="Create a new overlay schema version")

    migrate_parser = subparsers.add_parser("migrate", help="Migration sub-commands")
    migrate_parser.add_argument("--to", type=int, help="Target version to migrate to")
    migrate_parser.add_argument("--to-latest", action="store_true", help="Migrate to the latest version")

    args = parser.parse_args()
    logger = Logger(args.quiet)
    migrator = Migrator(logger)

    if args.command == "list":
        versions = migrator.get_available_versions()
        for version in versions:
            print(f"{version['version']} - {version['name']}")
    elif args.command == "status":
        with migrator._init_db() as conn, conn.cursor() as cursor:
            print(f"Current version: {migrator.get_current_version(cursor)}")
    elif args.command == "create":
        schema_details = migrator.create_schema()
        if schema_details:
            logger.info(f"New schema created: {schema_details}")
        else:
            logger.error("Failed to create schema!")
            sys.exit(1)
    elif args.command == "migrate":
        if args.to is not None and args.to_latest:
            logger.error("Cannot specify --to and --to-latest at the same time.")
            sys.exit(1)
        elif args.to_latest:
            versions = migrator.get_available_versions()
            if versions:  # Check if there are any versions available
                target_version = max(version['version'] for version in versions)
            else:
                logger.error("No migration versions found.")
                sys.exit(1)
        elif args.to is not None:
            target_version = args.to
        else:
            logger.error("Either --to or --to-latest must be specified.")
            sys.exit(1)

        migrator.migrate(target_version)

        migrator.migrate(target_version)
    else:
        parser.print_help()
        sys.exit(1)
